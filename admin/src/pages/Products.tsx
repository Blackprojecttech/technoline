import React, { useState, useEffect } from 'react'
import { Table, Button, Space, Tag, Image, Modal, message, Form, Input, InputNumber, TreeSelect, Switch, Upload, Card, Typography, Spin } from 'antd'
import { PlusOutlined, EditOutlined, DeleteOutlined, EyeOutlined, UploadOutlined, SaveOutlined, CheckCircleOutlined } from '@ant-design/icons'
import { useQuery, useMutation, useQueryClient } from 'react-query'

interface Category {
  _id: string
  name: string
  slug: string
  parentId?: string
  children?: Category[]
}

interface Product {
  _id: string
  name: string
  slug: string
  price: number
  costPrice?: number
  comparePrice?: number
  sku?: string
  mainImage: string
  isActive: boolean
  inStock: boolean
  stockQuantity: number
  categoryId: {
    _id: string
    name: string
  }
  description?: string
  createdAt: string
  updatedAt: string
  images?: string[] // Added images property
}

const Products: React.FC = () => {
  const [isModalVisible, setIsModalVisible] = useState(false)
  const [editingProduct, setEditingProduct] = useState<Product | null>(null)
  const [imageUploading, setImageUploading] = useState(false)
  const [uploadedImageUrl, setUploadedImageUrl] = useState<string>('')
  const queryClient = useQueryClient()

  const [form] = Form.useForm();
  const [uploading, setUploading] = useState(false);
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [fileList, setFileList] = useState<any[]>([]);
  const [previewVisible, setPreviewVisible] = useState(false);
  const [previewImage, setPreviewImage] = useState('');
  const [previewTitle, setPreviewTitle] = useState('');
  const [isSlugAutoGenerated, setIsSlugAutoGenerated] = useState(false);

  // Получение категорий
  const { data: categories } = useQuery<Category[]>('categories', async () => {
    const response = await fetch(`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/categories`)
    if (!response.ok) throw new Error('Failed to fetch categories')
    return response.json()
  })

  // Получение товаров
  const { data: productsData, isLoading } = useQuery('products', async () => {
    const response = await fetch(`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/products`)
    if (!response.ok) throw new Error('Failed to fetch products')
    return response.json()
  })
  const products = productsData?.products || [];

  // Преобразование категорий в формат для TreeSelect
  const transformCategoriesToTreeData = (categories: Category[]): any[] => {
    return categories.map(category => ({
      title: category.name,
      value: category._id,
      key: category._id,
      children: category.children ? transformCategoriesToTreeData(category.children) : undefined
    }))
  }

  // Загрузка изображения
  const handleImageUpload = async (file: File) => {
    setImageUploading(true)
    const formData = new FormData()
    formData.append('image', file)

    try {
      const response = await fetch(`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/upload/image`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('admin_token')}`
        },
        body: formData
      })

      if (!response.ok) {
        throw new Error('Failed to upload image')
      }

      const result = await response.json()
      const imageUrl = result.file.url
      setUploadedImageUrl(imageUrl)
      message.success('Изображение загружено успешно!')
      return false // Предотвращаем автоматическую загрузку
    } catch (error) {
      message.error('Ошибка при загрузке изображения')
      console.error('Upload error:', error)
    } finally {
      setImageUploading(false)
    }
    return false
  }

  const handleCancel = () => setPreviewVisible(false);
  const handlePreview = async (file: any) => {
    setPreviewImage(file.url || file.thumbUrl || (file.response && file.response.file && file.response.file.url));
    setPreviewVisible(true);
    setPreviewTitle(file.name || (file.url && file.url.split('/').pop()));
  };
  const handleChange = ({ fileList: newFileList }: { fileList: any[] }) => {
    setFileList(newFileList);
    form.setFieldsValue({ images: newFileList });
  };

  const normFile = (e: any) => Array.isArray(e) ? e : e && e.fileList;

  // Функция для генерации slug
  const generateSlug = (name: string): string => {
    return name
      .toLowerCase()
      .replace(/[а-яё]/g, (char: string) => {
        const map: { [key: string]: string } = {
          'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
          'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
          'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
          'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
          'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'
        };
        return map[char] || char;
      })
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  };

  // Создание товара
  const createProductMutation = useMutation({
    mutationFn: async (values: any) => {
      const productData = {
        ...values,
        mainImage: uploadedImageUrl || values.mainImage
      }
      
      const response = await fetch(`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/products`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('admin_token')}`
        },
        body: JSON.stringify(productData)
      })
      if (!response.ok) {
        throw new Error('Failed to create product')
      }
      return response.json()
    },
    onSuccess: () => {
      message.success('Товар создан успешно!')
      queryClient.invalidateQueries('products')
      setIsModalVisible(false)
      setEditingProduct(null)
      setUploadedImageUrl('')
    },
    onError: (error) => {
      message.error('Ошибка при создании товара')
      console.error('Create error:', error)
    }
  })

  // Обновление товара
  const updateProductMutation = useMutation({
    mutationFn: async ({ id, values }: { id: string; values: any }) => {
      const productData = {
        ...values,
        mainImage: uploadedImageUrl || values.mainImage
      }
      
      const response = await fetch(`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/products/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('admin_token')}`
        },
        body: JSON.stringify(productData)
      })
      if (!response.ok) {
        throw new Error('Failed to update product')
      }
      return response.json()
    },
    onSuccess: () => {
      message.success('Товар обновлен успешно!')
      queryClient.invalidateQueries('products')
      setIsModalVisible(false)
      setEditingProduct(null)
      setUploadedImageUrl('')
    },
    onError: (error) => {
      message.error('Ошибка при обновлении товара')
      console.error('Update error:', error)
    }
  })

  // Удаление товара
  const deleteProductMutation = useMutation({
    mutationFn: async (id: string) => {
      const response = await fetch(`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/products/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('admin_token')}`
        }
      })
      if (!response.ok) {
        throw new Error('Failed to delete product')
      }
      return response.json()
    },
    onSuccess: () => {
      message.success('Товар удален успешно!')
      queryClient.invalidateQueries('products')
    },
    onError: (error) => {
      message.error('Ошибка при удалении товара')
      console.error('Delete error:', error)
    }
  })

  const handleCreate = () => {
    setEditingProduct(null)
    setUploadedImageUrl('')
    setImageUrl('')
    setFileList([])
    setIsSlugAutoGenerated(false)
    form.resetFields()
    form.setFieldsValue({ 
      images: [],
      slug: '', // Явно устанавливаем пустой slug
      isActive: true,
      inStock: true,
      stockQuantity: 0,
      price: 0,
      costPrice: 0
    }) // Синхронизация Form и fileList
    setIsModalVisible(true)
  }

  const handleEdit = (record: Product) => {
    setEditingProduct(record)
    setUploadedImageUrl(record.mainImage)
    setImageUrl(record.mainImage)
    
    // Инициализируем fileList для изображений
    if (record.images && record.images.length > 0) {
      const initialFileList = record.images.map((url, index) => ({
        uid: `-${index}`,
        name: `image-${index}.jpg`,
        status: 'done' as const,
        url: url,
        response: { file: { url: url } }
      }));
      setFileList(initialFileList);
      form.setFieldsValue({ images: initialFileList }) // Синхронизация Form и fileList
    } else {
      setFileList([]);
      form.setFieldsValue({ images: [] }) // Синхронизация Form и fileList
    }
    
    // Устанавливаем значения формы
    form.setFieldsValue({
      name: record.name,
      description: record.description,
      slug: record.slug,
      categoryId: record.categoryId._id,
      price: record.price,
      costPrice: record.costPrice,
      sku: record.sku,
      stockQuantity: record.stockQuantity,
      isActive: record.isActive,
      inStock: record.inStock,
      mainImage: record.mainImage
    });
    
    // Проверяем, был ли slug автоматически сгенерирован
    const autoGeneratedSlug = generateSlug(record.name);
    setIsSlugAutoGenerated(record.slug === autoGeneratedSlug);
    
    setIsModalVisible(true)
  }

  const handleDelete = (id: string) => {
    Modal.confirm({
      title: 'Вы уверены, что хотите удалить этот товар?',
      content: 'Это действие нельзя отменить.',
      okText: 'Да',
      okType: 'danger',
      cancelText: 'Нет',
      onOk: () => deleteProductMutation.mutate(id)
    })
  }

  const handleModalOk = () => {
    const form = document.querySelector('form') as HTMLFormElement
    if (form) {
      form.dispatchEvent(new Event('submit', { bubbles: true }))
    }
  }

  const handleModalCancel = () => {
    setIsModalVisible(false)
    setEditingProduct(null)
    setUploadedImageUrl('')
    setImageUrl('')
    setFileList([])
    setIsSlugAutoGenerated(false)
    form.resetFields()
  }

  const onFinish = (values: any) => {
    const images = (values.images || [])
      .filter((f: any) => f.status === 'done')
      .map((f: any) => {
        const url = f.response?.file?.url || f.url;
        // Очищаем URL от параметра ?t=timestamp перед сохранением в базу
        return url ? url.split('?')[0] : url;
      });
    
    // Используем mainImage из формы или первое изображение из массива
    const mainImage = values.mainImage || images[0] || '';
    
    // Автоматически генерируем slug, если он не указан
    let slug = values.slug;
    
    if (!slug || slug.trim() === '') {
      slug = generateSlug(values.name);
    }
    
    if (editingProduct) {
      updateProductMutation.mutate({ id: editingProduct._id, values: { ...values, slug, mainImage, images } })
    } else {
      createProductMutation.mutate({ ...values, slug, mainImage, images })
    }
  }

  const columns = [
    {
      title: 'Изображение',
      dataIndex: 'images',
      key: 'images',
      render: (_: any, record: any) => {
        const imageUrl = record.images?.[0] || record.mainImage;
        const fullImageUrl = imageUrl ? 
          (imageUrl.startsWith('http') ? imageUrl : `${import.meta.env.VITE_API_URL || 'http://localhost:5002'}${imageUrl}`) 
          : undefined;
        
        return (
          <Image 
            width={60} 
            src={fullImageUrl}
            onError={(e) => {
              console.error('Error loading table image:', fullImageUrl);
              e.currentTarget.style.display = 'none';
            }}
            onLoad={() => {
              console.log('Table image loaded successfully:', fullImageUrl);
            }}
          />
        );
      },
    },
    {
      title: 'Название',
      dataIndex: 'name',
      key: 'name',
      render: (text: string) => <strong>{text}</strong>
    },
    {
      title: 'Slug',
      dataIndex: 'slug',
      key: 'slug',
      render: (slug: string, record: Product) => {
        const autoGeneratedSlug = generateSlug(record.name);
        const isAutoGenerated = slug === autoGeneratedSlug;
        
        return (
          <span style={{ 
            color: !slug || slug === '' ? '#ff4d4f' : isAutoGenerated ? '#52c41a' : '#1890ff',
            fontFamily: 'monospace',
            fontSize: '12px',
            display: 'flex',
            alignItems: 'center',
            gap: '4px'
          }}>
            {slug || 'НЕ УКАЗАН'}
            {isAutoGenerated && slug && (
              <span style={{ fontSize: '10px', color: '#52c41a' }} title="Автоматически сгенерирован">
                ✓
              </span>
            )}
          </span>
        )
      }
    },
    {
      title: 'Цена',
      dataIndex: 'price',
      key: 'price',
      render: (price: number) => `₽${price.toLocaleString()}`
    },
    {
      title: 'Категория',
      dataIndex: 'categoryId',
      key: 'categoryId',
      render: (category: any) => category?.name || 'Без категории'
    },
    {
      title: 'Статус',
      key: 'status',
      render: (record: Product) => (
        <Space>
          {record.isActive ? (
            <Tag color="green">Активен</Tag>
          ) : (
            <Tag color="red">Неактивен</Tag>
          )}
          {record.inStock ? (
            <Tag color="blue">В наличии</Tag>
          ) : (
            <Tag color="orange">Нет в наличии</Tag>
          )}
        </Space>
      )
    },
    {
      title: 'Действия',
      key: 'actions',
      render: (record: Product) => (
        <Space>
          <Button
            type="text"
            icon={<EyeOutlined />}
            onClick={() => {
              Modal.info({
                title: record.name,
                content: (
                  <div>
                    <p><strong>Описание:</strong> {record.description || 'Нет описания'}</p>
                    <p><strong>Цена:</strong> ₽{record.price.toLocaleString()}</p>
                    <p><strong>Цена закупки:</strong> ₽{record.costPrice?.toLocaleString() || 'Не указана'}</p>
                    <p><strong>SKU:</strong> {record.sku || 'Не указан'}</p>
                    <p><strong>Остаток:</strong> {record.stockQuantity} шт.</p>
                    <p><strong>Создан:</strong> {new Date(record.createdAt).toLocaleDateString()}</p>
                  </div>
                ),
                width: 600
              })
            }}
          />
          <Button
            type="text"
            icon={<EditOutlined />}
            onClick={() => handleEdit(record)}
          />
          <Button
            type="text"
            danger
            icon={<DeleteOutlined />}
            onClick={() => handleDelete(record._id)}
          />
          <Button
            type="text"
            icon={<EyeOutlined />}
            onClick={() => {
              const frontendUrl = 'http://localhost:3100';
              const productUrl = `${frontendUrl}/product/${record.slug}`;
              window.open(productUrl, '_blank');
            }}
            title="Просмотреть на сайте"
          />
        </Space>
      )
    }
  ]

  return (
    <div style={{ padding: '24px' }}>
      <Card>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
          <Typography.Title level={2} style={{ margin: 0 }}>
            Товары
          </Typography.Title>
          <Button
            type="primary"
            icon={<PlusOutlined />}
            onClick={handleCreate}
          >
            Добавить товар
          </Button>
        </div>

        <Table
          columns={columns}
          dataSource={products}
          rowKey="_id"
          loading={isLoading}
          pagination={{
            pageSize: 10,
            showSizeChanger: true,
            showQuickJumper: true,
            showTotal: (total, range) => `${range[0]}-${range[1]} из ${total} товаров`
          }}
        />
      </Card>

      <Modal
        title={editingProduct ? 'Редактировать товар' : 'Добавить товар'}
        open={isModalVisible}
        onOk={handleModalOk}
        onCancel={handleModalCancel}
        width={800}
        okText={editingProduct ? 'Обновить' : 'Создать'}
        cancelText="Отмена"
        confirmLoading={createProductMutation.isLoading || updateProductMutation.isLoading}
      >
        <Form
          layout="vertical"
          onFinish={onFinish}
          initialValues={editingProduct || {
            isActive: true,
            inStock: true,
            stockQuantity: 0,
            price: 0,
            costPrice: 0
          }}
          form={form}
        >
          <Form.Item
            name="name"
            label="Название товара"
            rules={[{ required: true, message: 'Введите название товара' }]}
          >
            <Input 
              placeholder="Введите название товара"
              onChange={(e) => {
                const slug = form.getFieldValue('slug');
                
                // Автоматически генерируем slug только если поле slug пустое или пользователь не вводил его вручную
                if (!slug || slug === '' || isSlugAutoGenerated) {
                  const generatedSlug = generateSlug(e.target.value);
                  form.setFieldsValue({ slug: generatedSlug });
                  setIsSlugAutoGenerated(true);
                }
              }}
              onBlur={(e) => {
                // При потере фокуса также генерируем slug, если он пустой
                const slug = form.getFieldValue('slug');
                const name = e.target.value;
                if ((!slug || slug === '') && name) {
                  const generatedSlug = generateSlug(name);
                  form.setFieldsValue({ slug: generatedSlug });
                  setIsSlugAutoGenerated(true);
                }
              }}
            />
          </Form.Item>

          <Form.Item
            name="description"
            label="Описание"
            rules={[{ required: true, message: 'Введите описание товара' }]}
          >
            <Input.TextArea rows={4} placeholder="Введите описание товара" />
          </Form.Item>

          <Form.Item
            name="slug"
            label="Slug (URL)"
            rules={[{ required: true, message: 'Введите slug или оставьте пустым для автоматической генерации' }]}
          >
            <Input 
              placeholder="Введите slug или оставьте пустым для автоматической генерации"
              onChange={(e) => {
                const name = form.getFieldValue('name');
                if (!e.target.value && name) {
                  const generatedSlug = generateSlug(name);
                  form.setFieldsValue({ slug: generatedSlug });
                  setIsSlugAutoGenerated(true);
                } else {
                  // Если пользователь ввел slug вручную, считаем его не автоматически сгенерированным
                  setIsSlugAutoGenerated(false);
                }
              }}
              addonAfter={
                <Button 
                  type="text" 
                  size="small"
                  onClick={() => {
                    const name = form.getFieldValue('name');
                    if (name) {
                      const generatedSlug = generateSlug(name);
                      form.setFieldsValue({ slug: generatedSlug });
                      setIsSlugAutoGenerated(true);
                      message.success('Slug сгенерирован автоматически');
                    } else {
                      message.warning('Сначала введите название товара');
                    }
                  }}
                  title="Сгенерировать slug из названия"
                >
                  🔄
                </Button>
              }
              suffix={
                isSlugAutoGenerated ? (
                  <span style={{ fontSize: '12px', color: '#52c41a' }}>
                    ✓ Авто-генерация
                  </span>
                ) : (
                  <span style={{ fontSize: '12px', color: '#999' }}>
                    Ручной ввод
                  </span>
                )
              }
            />
          </Form.Item>

          <Form.Item
            name="categoryId"
            label="Категория"
            rules={[{ required: true, message: 'Выберите категорию' }]}
          >
            <TreeSelect
              placeholder="Выберите категорию"
              treeData={categories ? transformCategoriesToTreeData(categories) : []}
              treeDefaultExpandAll={false}
              allowClear
              showSearch
              treeNodeFilterProp="title"
            />
          </Form.Item>

                      <Form.Item
              name="price"
              label="Цена продажи"
              rules={[{ required: true, message: 'Введите цену' }]}
            >
              <InputNumber
                style={{ width: '100%' }}
                placeholder="Введите цену"
                min={0}
                formatter={value => `₽ ${value}`.replace(/\B(?=(\d{3})+(?!\d))/g, ',')}
                parser={(value: string | undefined) => value ? Number(value.replace(/\₽\s?|(,*)/g, '')) : 0}
              />
            </Form.Item>

                      <Form.Item
              name="costPrice"
              label="Цена закупки"
            >
              <InputNumber
                style={{ width: '100%' }}
                placeholder="Введите цену закупки"
                min={0}
                formatter={value => `₽ ${value}`.replace(/\B(?=(\d{3})+(?!\d))/g, ',')}
                parser={(value: string | undefined) => value ? Number(value.replace(/\₽\s?|(,*)/g, '')) : 0}
              />
            </Form.Item>

          <Form.Item
            name="sku"
            label="SKU (артикул)"
          >
            <Input placeholder="Введите SKU" />
          </Form.Item>

          <Form.Item
            name="stockQuantity"
            label="Количество на складе"
            rules={[{ required: true, message: 'Введите количество' }]}
          >
            <InputNumber
              style={{ width: '100%' }}
              placeholder="Введите количество"
              min={0}
            />
          </Form.Item>

          <Form.Item
            name="mainImage"
            label="Главное изображение товара"
          >
            <Upload
              name="image"
              action={`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/upload/image`}
              showUploadList={false}
              headers={{
                Authorization: `Bearer ${localStorage.getItem('admin_token')}`,
              }}
              beforeUpload={file => {
                const isJpgOrPng = file.type === 'image/jpeg' || file.type === 'image/png';
                if (!isJpgOrPng) {
                  message.error('Можно загружать только JPG/PNG файлы!');
                  return Upload.LIST_IGNORE;
                }
                const isLt2M = file.size / 1024 / 1024 < 2;
                if (!isLt2M) {
                  message.error('Изображение должно быть меньше 2MB!');
                  return Upload.LIST_IGNORE;
                }
                return true;
              }}
              onChange={info => {
                if (info.file.status === 'uploading') {
                  setUploading(true);
                }
                if (info.file.status === 'done') {
                  setUploading(false);
                  if (info.file.response && info.file.response.file && info.file.response.file.url) {
                    const imageUrl = info.file.response.file.url;
                    form.setFieldsValue({ mainImage: imageUrl });
                    setImageUrl(imageUrl);
                    message.success('Изображение загружено!');
                  } else {
                    message.error('Ошибка: неверный ответ сервера');
                  }
                } else if (info.file.status === 'error') {
                  setUploading(false);
                  message.error('Ошибка загрузки изображения');
                }
              }}
            >
              {uploading ? <Spin /> : imageUrl ? (
                <div style={{ position: 'relative', display: 'inline-block' }}>
                  <img 
                    src={imageUrl.startsWith('http') ? imageUrl : `${import.meta.env.VITE_API_URL || 'http://localhost:5002'}${imageUrl}`}
                    alt="main" 
                    style={{ width: 100, borderRadius: 8, border: '1px solid #eee' }}
                    onError={(e) => {
                      console.error('Error loading image:', imageUrl);
                      e.currentTarget.style.display = 'none';
                    }}
                    onLoad={() => {
                      console.log('Image loaded successfully:', imageUrl);
                    }}
                  />
                  <CheckCircleOutlined style={{ color: 'green', position: 'absolute', top: 4, right: 4, fontSize: 24, background: '#fff', borderRadius: '50%' }} />
                </div>
              ) : (
                <Button icon={<UploadOutlined />}>Загрузить</Button>
              )}
            </Upload>
          </Form.Item>

          <Form.Item
            name="images"
            label="Изображения товара"
            valuePropName="fileList"
            getValueFromEvent={normFile}
            rules={[{ 
              validator: (_, value) => {
                if (!value || value.length === 0) {
                  return Promise.reject(new Error('Загрузите хотя бы одно изображение'));
                }
                const doneFiles = value.filter((f: any) => f.status === 'done');
                if (doneFiles.length === 0) {
                  return Promise.reject(new Error('Загрузите хотя бы одно изображение'));
                }
                return Promise.resolve();
              }
            }]}
          >
            <Upload
              name="image"
              action={`${import.meta.env.VITE_API_URL || 'http://localhost:5002/api'}/upload/image`}
              listType="picture-card"
              multiple
              maxCount={10}
              fileList={fileList}
              onPreview={handlePreview}
              onChange={handleChange}
              headers={{ Authorization: `Bearer ${localStorage.getItem('admin_token')}` }}
              showUploadList={{ showPreviewIcon: true, showRemoveIcon: true }}
            >
              {fileList.length >= 10 ? null : <div><PlusOutlined /><div>Загрузить</div></div>}
            </Upload>
            <Modal open={previewVisible} title={previewTitle} footer={null} onCancel={handleCancel}>
              <img 
                alt="example" 
                style={{ width: '100%' }} 
                src={previewImage.startsWith('http') ? previewImage : `${import.meta.env.VITE_API_URL || 'http://localhost:5002'}${previewImage}`}
                onError={(e) => {
                  console.error('Error loading preview image:', previewImage);
                  e.currentTarget.style.display = 'none';
                }}
                onLoad={() => {
                  console.log('Preview image loaded successfully:', previewImage);
                }}
              />
            </Modal>
          </Form.Item>

          <Form.Item
            name="isActive"
            label="Активен"
            valuePropName="checked"
          >
            <Switch />
          </Form.Item>

          <Form.Item
            name="inStock"
            label="В наличии"
            valuePropName="checked"
          >
            <Switch />
          </Form.Item>
        </Form>
      </Modal>
    </div>
  )
}

export default Products 